pragma solidity ^0.5.5;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract CrowdFunding {
  IERC20 public crowdFundingToken_;

  struct CrowdFundingProject {
    address owner;
    uint32 goal;
    uint32 balance;
    mapping (address => uint32) fundersBalances;
    address [] funders;
    bool open;
  }

  mapping (bytes32 => CrowdFundingProject) private projects_;
  bytes32[] private projectsHash_;

  constructor(IERC20 _crowdFundingToken) public {
    crowdFundingToken_ = _crowdFundingToken;
  }

  function projectExists(string memory _project) public view returns (bool) {
    bytes32 projectHash = keccak256(bytes(_project));

    for (uint32 it = 0; it < projectsHash_.length; it++) {
      if (projectHash == projectsHash_[it]) {
        return true;
      }
    }

    return false;
  }

  function isOpen(string memory _project) public view returns (bool) {
    require (true == projectExists(_project), "isOpen(): Invalid Project!");

    bytes32 projectHash = keccak256(bytes(_project));

    return projects_[projectHash].open;
  }

  function getBalance(string memory _project) public view returns (uint32) {
    require (true == projectExists(_project), "getBalance(): Invalid Project!");

    bytes32 projectHash = keccak256(bytes(_project));

    return projects_[projectHash].balance;
  }

  function getGoal(string memory _project) public view returns (uint32) {
    require (true == projectExists(_project), "getGoal(): Invalid Project!");

    bytes32 projectHash = keccak256(bytes(_project));

    return projects_[projectHash].goal;
  }

  function create(string memory _project, uint32 _goal) public returns (bool) {
    require (false == projectExists(_project), "create(): Invalid Project!");

    bytes32 projectHash = keccak256(bytes(_project));

    projectsHash_.push(projectHash);

    projects_[projectHash].owner = msg.sender;
    projects_[projectHash].goal = _goal;
    projects_[projectHash].balance = 0;
    projects_[projectHash].open = true;

    return true;
  }

  function deposit(string memory _project, uint32 _amount) public returns (bool) {
    bytes32 projectHash = keccak256(bytes(_project));

    require (
      true == projectExists(_project) &&
      true == projects_[projectHash].open &&
      _amount > 0,
      "deposit(): Invalid Project/Project Closed/Invalid Amount!"
    );

    crowdFundingToken_.transferFrom(msg.sender, address(this), _amount);

    projects_[projectHash].balance += _amount;
    projects_[projectHash].fundersBalances[msg.sender] += _amount;

    projects_[projectHash].funders.push(msg.sender);

    return true;
  }

  function withdraw(string memory _project, uint32 _amount) public returns (bool) {
    bytes32 projectHash = keccak256(bytes(_project));

    require (
      true == projectExists(_project) &&
      true == projects_[projectHash].open &&
      _amount <= projects_[projectHash].fundersBalances[msg.sender],
      "withdraw(): Invalid Project/Project Closed/Invalid Amount!"
    );

    crowdFundingToken_.transferFrom(address(this), msg.sender, _amount);

    projects_[projectHash].balance -= _amount;
    projects_[projectHash].fundersBalances[msg.sender] -= _amount;

    return true;
  }

  function close(string memory _project) public returns (bool) {
    bytes32 projectHash = keccak256(bytes(_project));

    require (
      true == projectExists(_project) &&
      true == projects_[projectHash].open &&
      msg.sender == projects_[projectHash].owner,
      "close(): Invalid Project/Project Closed/Unknown Sender!"
    );

    projects_[projectHash].open = false;

    return true;
  }

  function distributeFunding(string memory _project) public returns (bool) {
    bytes32 projectHash = keccak256(bytes(_project));

    require (
      true == projectExists(_project) &&
      false == projects_[projectHash].open &&
      msg.sender == projects_[projectHash].owner,
      "distributeFunding(): Invalid Project/Project Closed/Unknown Sender!"
    );

    crowdFundingToken_.transferFrom(address(this), msg.sender, projects_[projectHash].balance);

    return true;
  }
}
